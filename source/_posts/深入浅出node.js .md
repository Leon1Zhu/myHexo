---
title: 深入浅出node.js
date: 2018-05-26 16:30:51
tags: 深入浅出node.js一书读后感
categories: 读后感
---

![封面](http://otdc3q7z7.bkt.clouddn.com/8FEC2E9FF1FADB48B2665EF42FF46FF9.jpg)

### 第一章（简介）
#### node.js特点
 <!--more-->
- 单线程
 - 优点

   * 无需像多线程那样处处在意状态的同步问题
   * 没有死锁的存在
   * 不会有线程上下文交换所带来的性能上的开销
 - 缺点
   * 无法利用多核CPU
   * 一旦发生错误会导致整个应用退出，健壮性值得考研
   * 大量计算占用CPU导致无法继续调用异步I/O
在node中，长时间的CPU占用会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也不会及时执行（使用webwork可以解决这个问题，把大量的计算任务丢到另外一个线程去运行即可)

- node.js的适用场景
 * I/O密集型
 * CPU密集型应用也可以胜任（需要通过编写C/C++拓展或者通过子进程的方式来充分利用CPU）
 * 分布式应用

第一章主要是对node.js的一些简单介绍，后面都会进行详细的描述，所以这里就不做过多的叙述

### 第二章（模块机制）

#### CommonJS

- 模块定义
 ```javascript
 exports.add = function(){
    //......
    return  XX;
 }

```

- 模块引用
```javascript
  var math = require('math');
  return math.add();
```

- 模块标识
  * 标识其实就是传递给require方法的参数，必须符合驼峰命名的字符串，或者是.、..开头的相对路径，或者是绝对路径，可以没有后缀名称
  
##### 但是在node.js中对模块的实现并不是完全按照commonJS的规范来的，而是对规范进行了一定的取舍，具体的实现分为三个步骤
 * 路径分析(分析文件所在路径)
   * 不要让自定义的模块名称和核心模块的名称冲突，这样会加载出错。
   * 自定义模块的路径路径分析生成路径名称的方式和原型有点像，一层层往上找，知道找到为止，这也是为什么自定义模块加载慢的原因。
 * 文件定位（找到文件)
   * 当不写拓展名是，Node会自动按照js、json、node的次序去补足拓展名，同时会阻塞式的判断文件是否存在（因为js是单线程的），所以json和node文件带上后缀名会快一些
 * 编译执行（对模块进行编译执行）
   - 不同的文件Node的载入方法是不同的
     * .js文件，通过fs模块同步读取文件后编译执行
     * .node文件，通过dlopen()方法加载最后编译生成的文件
     * .json文件，通过fs模块同步读取文件之后，用JOSN.parse()解析结果返回
     * 其他文件，都被当做.js文件载入
   * 每一个编译成功的模块都会将其文件路径作为索引存在缓存上，以提高二次载入的性能
   
  * JS模块的编译中，Node对js的内容进行了头尾包装，用闭包作用域将每个模块进行隔离，包装过后通过VM模块进行执行，只是具有明确的上下文，不污染全局，返回一个具体的function对象。

Node对模块都会进行缓存，并且优先从缓存加载，当从缓存加载模块时，不需要路径分析和文件定位，大大提高了速度。

Node中模块分为两类，一类是Node本身的模块成为核心模块（http、fs、path等，省略文件定位和编译执行，并且路径分析优先，所以执行最快），另一类是其他用户编写的模块，称为文件模块。

通常不建议文件模块直接滴啊用内建模块，直接调用核心模块即可。


### 第三章(异步I/O)

##### js的单线程特点决定一定要有异步I/O，窦泽用户体验将会十分糟糕，并且将等在请求的资源分配给其他业务去执行

- 异步/同步I/O   阻塞/非阻塞I/O
 * 阻塞造成CPU等待浪费，非阻塞的轮询造成CPU资源浪费
 
- Node的I/O
 * 事件轮询机制，在进程中，Node会创建一个类似于while(true)的循环，不断的去询问是否有请求执行完成，需要处理，如果有就执行，如果没有就继续下一轮新循环。

- setTimeout setInterval

- process.nextTick()
 * 相对于setTimeout(function(){},0)调用红黑树去立即执行异步函数的做法，process.nextTick()只是将回调函数放入队列中，等待下一次的轮询调用，但是时间复杂度是O(1)而前者的时间复杂度是O(lg(n))
 
- setImmediate()
 * 和process.nextTick()差不多，有细微的差别
 * 优先级低于process.nextTick()
 * 当一个回调执行之后，并不会立即执行下一个，而是放到下一次事件轮询。，这是为了保证每次轮询能够比较快的执行结束。
 
#### 第四章 (异步编程)
 
 - 偏函数
  * 至通过指定部分参数来产生一个新的定制函数的形式
```javascript
    var toString = Object.prototype.toString;
    var isType = function(type){
        return toString.call(type) === '[object ' + type + ']';
    } 
```
  * 比如上面的函数，当有多个类型需要检查的时候就不需要一个一个的去重复写了，直接改变参数就能达到相同的目的。
  
 - 异步编程的优势与缺点
   - 优势
    * 非阻塞I/O可以使CPU与I/O并不互相依赖，让资源更好的利用。
    * 对于网络而言，并行带来的想象空间更大，延展而开的是分布式和云，并行使得各个单点之间能够更有效地组织起来。，所以Node在云计算厂商中广受青睐。
    * 对于海量请求同时作用于单线程上时，就要防止任何一个计算耗费过多的时间片。建议对CPU的耗时不要超过10ms，将大量的计算分解为诸多的小量计算，通过setImmediate()进行调度。
 - 难点
  * 异常处理，因为是异步，所以会比较难定位到错误的流程。
  * 函数且套过深（回调地狱）
  * 阻塞代码（单线程）
  * 异步转同步（async await）
 - 异步编程的解决方案
  - 事件发布/订阅模式
     * 如果对一个事件添加了超过10条侦听器，就会得到一条警告。防止发生内存泄露。使用emitter.setMMaxListeners(0);可以将这个限制去掉，另外，如果侦听器过多，可能会引起过多占用CPU的场景。
    * EventEmitter对error事件进行了特殊的处理，如果发生error，首先会查看是否对error增加了侦听器，如果没有就抛出异常，线程退出，所以健壮的观察者模式要对error添加侦听器。
    * Node中封装了继承的方法，使用util.inherits即可
    * 使用events.EventEmitter().once()可以让侦听器只触发一次，触发一次之后就移除，比如多次查询同一条没有缓存的sql时就可以使用这个方法
    * 可以使用EventProxy来对多异步事件进行处理，提供all、tail、after、not、any等方法对流程进行控制。详见书P80页介绍
  - Promise/Deferred模式
  
  - 流程控制库
  
#### 第五章 内存控制（如何高效的使用内存)

##### V8垃圾回收机制与内存限制
  - V8的内存限制
    * V8只能使用部分内存64位系统为1.4G，32位系统为0.7G
    * 在浏览器中，这样的大小绰绰有余，但是在服务端，却限制了开发者使用大内存的想法
    * V8的对象都是存储在堆内存中，当当前堆内存的大小不足时，则继续申请新的内存，知道超过V8的限制
    * 按照官方的说法，如果使用内存过多，垃圾清理的时间将会变长，有因为js是单线程，所以这对性能的影响比较严重，所以直接限制了可用内存的大小。
    * 可以使用 node --max-old-space-size=1700 test.js //单位为MB    node --max-new-space-size=1024 test.js  //单位为KB，在V8初始化时生效，而且一旦生效就不能再动态改变。
  - V8的垃圾回收机制
    * 分为新生代和老生代内存
    * 新生代使用from和to空间进行清理（因为死亡对象相对较多)
    * 老生代使用标记清除方法进行清理(因为死亡对象相对较少)
    * 老生代清理之后会产生不连续的内存片段，所以使用Mark-Compack方法，直接把活着的对象移动到一边，吧剩下的直接清除
    * 每一次垃圾回收都会造成全停顿，会将整个应用程序的进程停下来，防止应用逻辑和垃圾回收机制看到的不一样
    * 新生代会直接全停顿，因为配置较小，所以无所谓
    * 老生代因为配置较大，所以需要分步清理，没做完一步，就让js执行一小会儿。
    * 详见书P113
  - 高效使用内存
    * 使用闭包和全局变量引用都会导致内存无法立即会搜，要小心使用此类变量，因为这些会导致老生代中的对象增多。
    - 可能会造成内存泄露的情况
      * 缓存
      * 队列消费不及时
      * 作用域未释放
    - 慎将内存当做缓存
      * 一旦一个独享被当做缓存使用，哪么就会放在老生代当中，常驻在内存里，如果这样的对象过多,就会导致垃圾回收机制在进行扫描时做无用功。
      * 而且使用js的键值对进行缓存严格意义上来说不算是缓存，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有
      * 所以使用键值对进行缓存数据的时候应当加以限制，只能小量暂时使用。
      * 由于模块是编译之后缓存在内存中，所以是常驻在老生代中，在设计模块的时候一定要十分小心内存泄露的情况。如果不可避免的话就添加清空队列的相应接口，以供调用者释放内存。
      * 可以将缓存移到外部，可以使用redis或者Memcached
    - 大内存应用
      * 读写大文件时，无法通过fs。readFile和fs.writeFile直接怼文件进行操作，应当改用 fs.createReadStream和fs.createWriteStream方法通过流的方式实现对大文件的操作
      * 对于可读流，同样也可以使用管道pipe()方法，同时通过流的方式，文件读取就不会受到V8的限制，有效的提高了程序的健壮性。

#### 第六章 Buffer
##### Buffer结构
  - 模块结构
    * Bufer是C++结合JS实现的 ，性能部分使用C++，非性能部分使用js实现
    * 因为Buffer太过常见，Node在启动的时候就加载了它，并且放在全局对象，所以不用require
    * 当对Buffer进行读取字符串拼接操作时，有可能会发生乱码的情况 
---
title: 你不知道的js阅读小计
date: 2018-11-29  14:18:49
tags:
categories: 读后感
---
### 作用域相关
 ```javascript
 var a = 2;
浏览器的处理逻辑
1. 遇到var a,编译器会询问作用于是否有一个该名称的变量存在于同一个作用于集合中，若有，则忽略该条，继续编译，否则会要求当前作用域在在当前作用域集合中声明一个新变量，并命名a。
2.接下来编译器会为引擎生成运行时所需要的代码，用来处理a = 2操作。此时引擎会先询问作用域是否存在变量a，如果是，就使用这个变量，并将2赋值给a，否则继续向上查找，直到超出作用域，抛出一个异常。
总结： 编译器会首先声明一个变量（如果之前没有声明过），然后运行时引擎会查找该变量并对该变量进行赋值。

同时，在这个例子中，也存在LHS和RHS查询，L和R分别表示一个赋值操作的左侧和右侧。
RHS只是简单的找到这个变量的值，而LHS是找到这个变量的容器本身。
```
注： 不成功的LHS会抛出一个（ReferenceError）异常，而一个不成功RHS会创建一个全局变量（费严格模式下）

### 此法作用域
 * js本身会在编译阶段进行数项的性能优化。但是如果使用eval或者with的话，编译器无法明确的知道会接受到什么样的代码，所以这些优化都会无效，所以不建议使用eval或者with
 * 遮蔽效应
 指由于作用域查找会在找到第一个匹配的值时停止，所以在多层嵌套的作用域中，内部的标识符遮蔽了外部的标识符。
 注：词法作用域只会查找一级标识符，比如foo.bar.baz，此法作用域只会试图查找foo，当找到foo变量时，对象访问规则便会分别接管对bar和baz的访问权限。
 ```javascript
with关键字可能会导致变量的泄露，看如下代码
 function foo(obj) {
    with(obj) {
        a = 2;
    }
 }
 
 var o1 = {
    a = 3;
 }
 
 var o2 = {
    b = 2;
 }
 
 foo(o1);
 foo(o1);
 在这段代码中，当第二次执行foo函数时，因为o2并没有a属性，此时程序会自动创建一个a变量并绑定到全局作用域中。
```